function Transformation(a,b){Array.call(this,a),this.length=a,this.size=a;for(var c=0;c<a;c++)this[c]=new Array(a);if(b)for(c=0;c<a;c++)for(var d=0;d<a;d++)c<b.length&&d<b[c].length?this[c][d]=b[c][d]:this[c][d]=c==d?1:0}function Mat4(){Transformation.call(this,4),this[0]=[1,0,0,0],this[1]=[0,1,0,0],this[2]=[0,0,1,0],this[3]=[0,0,0,1]}function Mat3(a){Transformation.call(this,3,a),a||(this[0]=[1,0,0],this[1]=[0,1,0],this[2]=[0,0,1])}function Vector(a){Array.call(this,a),this.length=a||0}function _argumentsToArray(a){return[].concat.apply([],Array.prototype.slice.apply(a))}function vec2(){var a=new Vector;for(a.push.apply(a,_argumentsToArray(arguments)),a.length>2&&(a=a.slice(0,2));a.length<2;)a.push(0);return a}function vec3(){var a=new Vector;for(a.push.apply(a,_argumentsToArray(arguments)),a.length>3&&(a=a.slice(0,3));a.length<3;)a.push(0);return a}function vec4(){var a=new Vector;for(a.push.apply(a,_argumentsToArray(arguments)),a.length>4&&(a=a.slice(0,4));a.length<3;)a.push(0);return a.length<4&&a.push(1),a}function radians(a){return a*Math.PI/180}function degrees(a){return 180*a/Math.PI}function Cartesia(){this.children=[],this.parent=null}function SimpleCartesia(){Cartesia.call(this),this.position=vec3(),this.roll=0,this.pitch=0,this.yaw=0,this.scale=1}function TriangleMeshSimpleCartesia(a){SimpleCartesia.call(this),this.mesh=a}function CustomCartesia(){Cartesia.call(this),this.transformation=new Mat4}function TextureSquare(a){TriangleMeshSimpleCartesia.call(this,new TriangleMesh({key:"texturesquare",vertices:this.corners,indices:this.triangles,color:vec4(1,1,1)})),this.mesh.texCoords=this.texCoords,this.mesh.texture=a}function BackgroundCartesia(a){TextureSquare.call(this,a)}function LightCartesia(a,b){SimpleCartesia.call(this),this.color=a||vec4(1,1,1,1),this.attenuation=b||0}function TriangleMesh(a){this.key=a.key,this.triangles=a.triangles||this.calcTriangles(a.vertices,a.indices),this.normals=a.normals||this.calcNormals(),this.material=this.setMaterial(a),this.texture=a.texture}function WebGLWrapper(a,b){var c=document.getElementById(a),d=WebGLUtils.setupWebGL(c);d||alert("WebGL isn't available"),d.viewport(0,0,c.width,c.height),d.clearColor(0,0,0,1),d.enable(d.DEPTH_TEST),d.depthFunc(d.LEQUAL),this.canvas=c,this.gl=d,this.loadedHandlers={},this.useShaders(b||PhongShader),this.lightPosition=vec4(5,3,5,1),this.lightAmbient=vec4(.2,.2,.2,1),this.lightDiffuse=vec4(.7,.7,.7,1),this.lightAttenuation=.05,this.lightSpecular=vec4(1,1,1,1),this.scene=null,this.camera=null,this.started=!0,this.verticesCache={},this.normalsCache={},WebGLWrapper.POINTS=d.POINTS,WebGLWrapper.LINES=d.LINES,WebGLWrapper.LINE_LOOP=d.LINE_LOOP,WebGLWrapper.LINE_STRIP=d.LINE_STRIP,WebGLWrapper.TRIANGLES=d.TRIANGLES,WebGLWrapper.TRIANGLE_STRIP=d.TRIANGLE_STRIP,WebGLWrapper.TRIANGLE_FAN=d.TRIANGLE_FAN}function Shader(a){var b=a.gl;this.glwrapper=a,this.getExtensions();var c,d;if(c=b.createShader(b.VERTEX_SHADER),b.shaderSource(c,this.vertexShader),b.compileShader(c),!b.getShaderParameter(c,b.COMPILE_STATUS))throw"Vertex shader compilation error.\n    "+b.getShaderInfoLog(c);if(d=b.createShader(b.FRAGMENT_SHADER),b.shaderSource(d,this.fragmentShader),b.compileShader(d),!b.getShaderParameter(d,b.COMPILE_STATUS))throw"Vertex shader compilation error.\n    "+b.getShaderInfoLog(d);var e=b.createProgram();if(b.attachShader(e,c),b.attachShader(e,d),b.linkProgram(e),!b.getProgramParameter(e,b.LINK_STATUS))throw"Shader program link error:\n    "+b.getProgramInfoLog(e);this.program=e}function PhongShader(a){Shader.call(this,a),this.vPosition=gl.getAttribLocation(this.program,"vPosition"),this.vNormal=gl.getAttribLocation(this.program,"vNormal")}function GouraudShader(a){PhongShader.call(this,a)}function BasicShader(a){Shader.call(this,a),this.vPosition=gl.getAttribLocation(this.program,"vPosition")}function BasicGBufferShader(a){BasicShader.call(this,a);for(var b=this.ext,c=a.canvas,d=new Array(4),e=0;e<d.length;e++)d[e]=gl.createTexture(),gl.bindTexture(gl.TEXTURE_2D,d[e]),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,c.width,c.height,0,gl.RGBA,gl.FLOAT,null),gl.bindTexture(gl.TEXTURE_2D,null);if(this.fb=gl.createFramebuffer(),gl.bindFramebuffer(gl.FRAMEBUFFER,this.fb),b.drawBuffersWEBGL([b.COLOR_ATTACHMENT0_WEBGL,b.COLOR_ATTACHMENT1_WEBGL,b.COLOR_ATTACHMENT2_WEBGL,b.COLOR_ATTACHMENT3_WEBGL]),gl.framebufferTexture2D(gl.FRAMEBUFFER,b.COLOR_ATTACHMENT0_WEBGL,gl.TEXTURE_2D,d[0],0),gl.framebufferTexture2D(gl.FRAMEBUFFER,b.COLOR_ATTACHMENT1_WEBGL,gl.TEXTURE_2D,d[1],0),gl.framebufferTexture2D(gl.FRAMEBUFFER,b.COLOR_ATTACHMENT2_WEBGL,gl.TEXTURE_2D,d[2],0),gl.framebufferTexture2D(gl.FRAMEBUFFER,b.COLOR_ATTACHMENT3_WEBGL,gl.TEXTURE_2D,d[3],0),this.depthBuffer=gl.createRenderbuffer(),gl.bindRenderbuffer(gl.RENDERBUFFER,this.depthBuffer),gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,c.width,c.height),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this.depthBuffer),a.texs=d,gl.checkFramebufferStatus(gl.FRAMEBUFFER)!=gl.FRAMEBUFFER_COMPLETE)throw"Error setting up Framebuffer"}function TextureShader(a){BasicShader.call(this,a),this.vTexCoord=gl.getAttribLocation(this.program,"vTexCoord"),this.textureBuffer=gl.createBuffer()}function BackgroundShader(a){Shader.call(this,a),this.vCoordBuffer=gl.createBuffer(),this.vCoord=gl.getAttribLocation(this.program,"vCoord"),this.textureBuffer=gl.createBuffer()}function BasicQuadShader(a){BackgroundShader.call(this,a)}function GBufferShader(a){BasicGBufferShader.call(this,a)}function PhongQuadShader(a){BasicQuadShader.call(this,a)}function Camera(a,b,c){SimpleCartesia.call(this),this.fov=a||45,this.near=b||.1,this.far=c||-1}function Cube(a){var b=new TriangleMesh({key:"cube",vertices:this.corners,indices:this.triangles,color:a});TriangleMeshSimpleCartesia.call(this,b)}function triangulateSphere(a,b){var c=b,d=b;a=1;for(var e=[],f=[],g=[],h=0;h<=c;h++)for(var i=h*Math.PI/c,j=Math.sin(i),k=Math.cos(i),l=0;l<=d;l++){var m=2*l*Math.PI/d,n=Math.sin(m),o=Math.cos(m),p=o*j,q=k,r=n*j;e.push(vec3(p,q,r)),f.push(vec3(a*p,a*q,a*r))}for(var h=0;h<c;h++)for(var l=0;l<d;l++){var s=h*(d+1)+l,t=s+1,u=s+d+1,v=u+1;g.push([s,t,v]),g.push([s,v,u])}return{normals:e,corners:f,indices:g}}function Sphere(a,b,c,d){TriangleMeshSimpleCartesia.call(this),this.color=a||vec4(1,1,1),this.shadeStyle=d||"phong";var e=triangulateSphere(1,c||20);this.triangles=e.indices.map(function(a){return a.map(function(a){return e.corners[a]})}),this.smoothNormals=e.indices.map(function(a){return a.map(function(a){return e.normals[a]})}),this.smoothMesh=new TriangleMesh({key:"Sphere_smooth_"+c,triangles:this.triangles,normals:this.smoothNormals,color:a}),this.flatMesh=new TriangleMesh({key:"Sphere_flat_"+c,triangles:this.triangles,color:a}),this.setScale(b)}WebGLUtils=function(){var a=function(a){return'<table style="background-color: #8CE; width: 100%; height: 100%;"><tr><td align="center"><div style="display: table-cell; vertical-align: middle;"><div style="">'+a+"</div></div></td></tr></table>"},b='This page requires a browser that supports WebGL.<br/><a href="http://get.webgl.org">Click here to upgrade your browser.</a>',c='It doesn\'t appear your computer can support WebGL.<br/><a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>',d=function(d,f){function g(b){var c=d.parentNode;c&&(c.innerHTML=a(b))}if(!window.WebGLRenderingContext)return g(b),null;var h=e(d,f);return h||g(c),h},e=function(a,b){for(var c=["webgl","experimental-webgl","webkit-3d","moz-webgl"],d=null,e=0;e<c.length;++e){try{d=a.getContext(c[e],b)}catch(a){}if(d)break}return d};return{create3DContext:e,setupWebGL:d}}(),window.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(a,b){window.setTimeout(a,1e3/60)}}(),Transformation.Generate=function(a,b){return new Transformation(a).populate(b)},Transformation.UniformScale=function(a,b){return Transformation.Generate(a,function(c,d){return c==d?d<a-1&&c<a-1?b:1:0})},Transformation.Scale=function(a){var b=a.length+1;return Transformation.Generate(b,function(c,d){return c==d?d<b-1&&c<b-1?a[c]:1:0})},Transformation.Translate=function(a){var b=a.length+1;return Transformation.Generate(b,function(c,d){return d==b-1&&c<b-1?a[c]:c==d?1:0})};var proto={spawn:function(a){return new Transformation(void 0!==a?a:this.size)},populate:function(a){for(var b=0;b<this.size;b++)for(var c=0;c<this.size;c++)this[b][c]=a.call(this,b,c)||0;return this},row:function(a){return this[a]},col:function(a){return this.map(function(b){return b[a]})},flatten:function(){var a=[];return this.transpose().forEachCell(function(b){a.push(b)}),a},forEachRow:function(a){this.forEach(a,this)},forEachCol:function(a){var b=a.bind(this);this.transpose().forEachRow(b)},forCellInRow:function(a,b){this.row(a).forEach(function(c,d){b(c,a,d)},this)},forCellInCol:function(a,b){this.col(a).forEach(function(c,d){b(c,d,a)},this)},forEachCell:function(a){for(var b=0;b<this.size;b++)for(var c=0;c<this.size;c++)a.call(this,this[b][c],b,c)},cellMap:function(a){for(var b=this.spawn(),c=0;c<this.size;c++)for(var d=0;d<this.size;d++)b[c][d]=a.call(this,this[c][d],c,d)||0;return b},append:function(a){var b=this;if(b.size!=a.size)throw"can't multiply matrices of different dimensions";return this.spawn().populate(function(c,d){for(var e=0,f=0;f<this.size;f++)e+=b[c][f]*a[f][d];return e})},prepend:function(a){return a.append(this)},transpose:function(){return this.cellMap(function(a,b,c){return this[c][b]})},subMatrix:function(a,b){if(0===this.size)throw"no submatrix of matrix with zero size";var c=this;return Transformation.Generate(this.size-1,function(d,e){return c[d<a?d:d+1][e<b?e:e+1]})},determinant:function(a){if(0===this.size)return 1;for(var b=0,c=0,d=0;d<this.size;d++){var e=a?a[b][d]:this.cofactor(b,d);c+=this[b][d]*e}return c},minor:function(a,b){return this.subMatrix(a,b).determinant()},cofactor:function(a,b){var c=(a+b)%2?1:-1,d=this.minor(a,b);return c*d},cofactorMatrix:function(){return this.cellMap(function(a,b,c){return this.cofactor(b,c)})},adjoint:function(){return this.cofactorMatrix().transpose()},inverse:function(){var a=this.cofactorMatrix(),b=this.determinant(a);if(0===b)throw"Can't take inverse if matrix determinant is zero";var c=a.transpose();return c.cellMap(function(a){return a/b})},transformVector:function(a){if(this.size!==a.length)throw"Transformation and vector have different sizes";for(var b=new Array(a.length),c=0;c<this.size;c++){b[c]=0;for(var d=0;d<this.size;d++)b[c]+=this[c][d]*a[d]}return b}};Transformation.prototype=Object.create(Array.prototype);for(var key in proto)Transformation.prototype[key]=proto[key];var proto={spawn:function(a){return new Mat4},scale:function(a){if(!a.length)return this.append(Transformation.UniformScale(4,a));if(3!==a.length)throw"Mat4.scale() takes either a single number of a vector of length 3";return this.append(Transformation.Scale(a))},translate:function(a){if(3!==a.length)throw"Mat4.translate() takes a vector with length 3";return this.append(Transformation.Translate(a))},rotate:function(a,b){var c=b.normalize(),d=Math.cos(radians(a)),e=1-d,f=Math.sin(radians(a));return this.append(this.spawn().populate(function(a,b){return a==this.size-1||b==this.size-1?a==b?1:0:c[a]*c[b]*e+(a==b?d:(b==(a+1)%3?-1:1)*c[3-a-b]*f)}))},perspective:function(a,b,c,d){var e=1/Math.tan(radians(a)/2),f=d-c,g=new Mat4;return g[0][0]=e/b,g[1][1]=e,g[2][2]=-(c+d)/f,g[2][3]=-2*c*d/f,g[3][2]=-1,g[3][3]=0,this.append(g)},rotateYAxisTo:function(a){return this.rotateVectorToMatch(vec3(0,1,0),a)},rotateVectorToMatch:function(a,b){var c=a.normalize(),d=b.normalize();if(Vector.equal(d,c))return new Mat4;var e=Vector.cross(c,d),f=degrees(Math.acos(Vector.dot(c,d)));return(new Mat4).rotate(f,e)}};Mat4.prototype=Object.create(Transformation.prototype);for(var key in proto)Mat4.prototype[key]=proto[key];var proto={spawn:function(a){return new Mat3},scale:function(a){if(!a.length)return this.append(Transformation.UniformScale(3,a));if(2!==a.length)throw"Mat3.scale() takes either a single number of a vector of length 2";return this.append(Transformation.Scale(a))},translate:function(a){if(2!==a.length)throw"Mat3.translate() takes a vector with length 2";return this.append(Transformation.Translate(a))},rotate:function(a){var b=Math.cos(radians(a)),c=Math.sin(radians(a));return this.append(new Mat3([[b,-c,0],[c,b,0],[0,0,1]]))}};Mat3.prototype=Object.create(Transformation.prototype);for(var key in proto)Mat3.prototype[key]=proto[key];Vector.fromArray=function(a){var b=new Vector;return b.push.apply(b,a),b},Vector.equal=function(a,b){if(a.length!==b.length)return!1;for(var c=0;c<a.length;c++)if(a[c]!==b[c])return!1;return!0},Vector.add=function(a,b){if(a.length!==b.length)throw"expects vectors of same length";for(var c=new Vector,d=0;d<a.length;d++)c.push(a[d]+b[d]);return c},Vector.subtract=function(a,b){if(a.length!==b.length)throw"expects vectors of same length";for(var c=new Vector,d=0;d<a.length;d++)c.push(a[d]-b[d]);return c},Vector.multiply=function(a,b){if(a.length!==b.length)throw"expects vectors of same length";for(var c=new Vector,d=0;d<a.length;d++)c.push(a[d]*b[d]);return c},Vector.dot=function(a,b){if(a.length!=b.length)throw"expects vectors of same length";for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c},Vector.cross=function(a,b){if(a.length<3)throw"First argument is not a vector of at least 3";if(b.length<3)throw"Second argument is not a vector of at least 3";var c=Vector.fromArray([a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]);return c};var proto={slice:function(a,b){return Vector.fromArray(Array.prototype.slice.call(this,a,b))},negate:function(){for(var a=new Vector,b=0;b<this.length;++b)a.push(-this[b]);return a},magnitude:function(){for(var a=0,b=0;b<this.length;b++)a+=this[b]*this[b];return Math.sqrt(a)},scale:function(a,b){for(var c=new Vector,d=0;d<this.length;++d)c.push(b&&d==this.length-1?this[d]:this[d]*a);return c},normalize:function(a){var b=a?this.slice(0,-1):this,c=b.magnitude();if(!isFinite(c))throw"Can't normalize vector with zero magnitude";var d=b.scale(1/c);return a&&d.push(this[this.length-1]),d},add:function(a){return Vector.add(this,a)},subtract:function(a){return Vector.subtract(this,a)},dot:function(a){return Vector.dot(this,a)},cross:function(a){return Vector.cross(this,a)},equal:function(a){return Vector.equal(this,a)}};Vector.prototype=Object.create(Array.prototype);for(var key in proto)Vector.prototype[key]=proto[key];Cartesia.prototype={getTransform:function(){throw"getTransform() of Cartesia is an abstract method! Did you mean to instantiate SimpleCartesia?"},getAbsoluteTransform:function(a){var b=a||this.parent&&this.parent.getAbsoluteTransform()||new Mat4;return b.append(this.getTransform())},getAbsolutePosition:function(a){return vec3.apply(this,this.getAbsoluteTransform().col(3))},setParent:function(a){return a.children.push(this),this.parent=a,this},addChild:function(a){return a.setParent(this),this},draw:function(a,b){var c=this.getAbsoluteTransform(b);this.children.forEach(function(b){b.draw(a,c)})}};var proto={setPosition:function(a){return this.position=a,this},move:function(a){return this.setPosition(this.position.add(a)),this},moveInDirection:function(a){var b=(new Mat4).rotate(this.pitch,vec3(1,0,0)).rotate(this.yaw,vec3(0,1,0)).rotate(this.roll,vec3(0,0,1)).transformVector(vec4.apply(this,a));return this.move(vec3.apply(this,b)),this},resetPosition:function(){return this.moveTo(this.initialPosition),this},resetRotation:function(){return this.roll=0,this.pitch=0,this.yaw=0,this},resetScale:function(){return this.scale=1,this},reset:function(){return this.resetPosition().resetRotation().resetScale(),this},movePitch:function(a){return this.pitch+=a,this},moveYaw:function(a){return this.yaw+=a,this},moveRoll:function(a){return this.roll+=a,this},setScale:function(a){return this.scale=a,this},scaleBy:function(a){return this.setScale(this.scale*a),this},getTransform:function(){var a=(new Mat4).rotate(this.pitch,vec3(1,0,0)).rotate(this.yaw,vec3(0,1,0)).rotate(this.roll,vec3(0,0,1));return(new Mat4).translate(this.position).append(a).scale(this.scale)}};SimpleCartesia.prototype=Object.create(Cartesia.prototype);for(var prop in proto)SimpleCartesia.prototype[prop]=proto[prop];var proto={draw:function(a,b){var c=this.getAbsoluteTransform(b);return a.drawTriangleMesh(this.mesh,c),this.children.forEach(function(b){b.draw(a,c)}),this}};TriangleMeshSimpleCartesia.prototype=Object.create(SimpleCartesia.prototype);for(var prop in proto)TriangleMeshSimpleCartesia.prototype[prop]=proto[prop];var proto={setTransform:function(a){return this.transformation=a,this},applyTransform:function(a){return this.setTransform(this.transformation.append(a)),this},getTransform:function(){return this.transformation}};CustomCartesia.prototype=Object.create(Cartesia.prototype);for(var key in proto)CustomCartesia.prototype[key]=proto[key];var proto={corners:[vec3(-1,-1,0),vec3(1,-1,0),vec3(1,1,0),vec3(-1,1,0)],triangles:[[0,1,2],[0,2,3]],texCoords:[vec2(0,0),vec2(1,0),vec2(1,1),vec2(0,0),vec2(1,1),vec2(0,1)],setTexture:function(a){this.mesh.texture=a}};TextureSquare.prototype=Object.create(TriangleMeshSimpleCartesia.prototype);for(var prop in proto)TextureSquare.prototype[prop]=proto[prop];rootCartesia=new SimpleCartesia;var proto={draw:function(a){return BackgroundShader.draw(a,this.mesh),this.children.forEach(function(b){b.draw(a,transform)}),this}};BackgroundCartesia.prototype=Object.create(TextureSquare.prototype);for(var prop in proto)BackgroundCartesia.prototype[prop]=proto[prop];var proto={draw:function(a,b){var c=this.getAbsoluteTransform(b);return a.glwrapper.lights.push({color:this.color,transform:c,attenuation:this.attenuation}),this.children.forEach(function(b){b.draw(a,c)}),this}};LightCartesia.prototype=Object.create(SimpleCartesia.prototype);for(var key in proto)LightCartesia.prototype[key]=proto[key];TriangleMesh.prototype={calcTriangles:function(a,b){if(!a||!b)throw"Please give either triangle data or vertex and index data to construct a Mesh";return b.map(function(b){return b.map(function(b){return a[b]})})},calcNormals:function(){return this.triangles.map(function(a){var b=Vector.cross(a[1].subtract(a[0]),a[2].subtract(a[1])).normalize();return[b,b,b]})},calcMaterial:function(a){this.ambientFactor=a.ambient&&!a.ambient.length?a.ambient:.1,this.diffuseFactor=a.diffuse&&!a.diffuse.length?a.diffuse:.7,this.specularFactor=a.specular&&!a.specular.length?a.specular:1,this.shininess=a.shininess||5,this.ambient=a.ambient&&a.ambient.length?a.ambient:this.color.scale(this.ambientFactor,!0),this.diffuse=a.diffuse&&a.diffuse.length?a.diffuse:this.color.scale(this.diffuseFactor,!0),this.specular=a.specular&&a.specular.length?a.specular:this.color.scale(this.specularFactor,!0)},setMaterial:function(a){this.color=a.color||vec4(1,1,1,1),this.calcMaterial(a)},setColor:function(a){this.setMaterial({color:a})}},WebGLWrapper.prototype={gl:null,program:null,canvas:null,pUniform:null,mvUniform:null,useShaders:function(a){if(gl=this.gl,this.shaderHandler&&this.shaderHandler.disableAttributes(),!a.prototype.key)throw"shader container needs a key (unique id) for caching!";var b=this.loadedHandlers[a.prototype.key];b||(b=Object.create(a.prototype),a.call(b,this),this.loadedHandlers[a.prototype.key]=b),gl.useProgram(b.program),b.initUniforms(),b.initBuffersAndAttributes(),this.shaderHandler=b},useScene:function(a){this.scene=a},useCamera:function(a){this.camera=a;var b=this.canvas.width/this.canvas.height;a.calcPerspective(b)},beforeRender:function(){},render:function(){this.beforeRender(),this.gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT),this.shaderHandler.renderScene(this.scene,this.camera)},start:function(){this.started=!0;var a=this;!function b(){a.started&&requestAnimFrame(b),a.render()}()},stop:function(){this.started=!1},createTexture:function(a,b,c,d,e){var f=this.gl,g=f.createTexture();return f.activeTexture(f.TEXTURE0),f.bindTexture(f.TEXTURE_2D,g),f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL,!0),f.texImage2D(f.TEXTURE_2D,0,f.RGBA,f.RGBA,f.UNSIGNED_BYTE,a),f.generateMipmap(f.TEXTURE_2D),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,b),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,c),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,d),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,e),f.bindTexture(f.TEXTURE_2D,null),g}},Shader.prototype={getExtensions:function(){},initUniforms:function(){},initBuffersAndAttributes:function(){},renderScene:function(){throw"Unimplemented Shader.renderScene()"},drawTriangleMesh:function(a,b){throw"Unimplemented Shader.drawTriangleMesh()"},flatten:function(a){for(var b=new Float32Array(a.length),c=0;c<a.length;++c)b[c]=a[c];return b},flattenVertices:function(a){for(var b=[],c=0;c<a.length;c++)for(var d=0;d<a[c].length;d++)b.push(a[c][d]);return this.flatten(b)},flattenTriangles:function(a){for(var b=[],c=0;c<a.length;c++)for(var d=0;d<a[c].length;d++)for(var e=0;e<a[c][d].length;e++)b.push(a[c][d][e]);return this.flatten(b)},flattenTransform:function(a){return this.flatten(a.flatten())}};var proto={key:"phong",vertexShader:"\t\t                                                                       \n\t\tattribute vec4 vPosition;                                              \n\t\tattribute vec4 vNormal;                                                \n\t\t                                                                       \n\t\tvarying vec3 N, L, E, D;                                               \n\t\tuniform mat4 CameraMat;                                                \n\t\tuniform mat4 ProjectMat;                                               \n\t\tuniform mat4 ModelMat;                                                 \n\t\tuniform vec4 lightPosition;                                            \n\t\tuniform mat3 normalMatrix;                                             \n\t\t                                                                       \n\t\tvoid main()                                                            \n\t\t{                                                                      \n\t\t    vec3 pos = (ModelMat * vPosition).xyz;                             \n\t\t                                                                       \n\t\t    // check for directional light                                     \n\t\t                                                                       \n\t\t    if(lightPosition.w == 0.0) {                                       \n\t\t    \tL = normalize(lightPosition.xyz);                              \n\t\t    \tD = vec3(0.0, 0.0, 0.0); // forces attenuation to 0            \n\t\t    } else {                                                           \n\t\t    \tL = normalize( lightPosition.xyz - pos );                      \n\t\t    \tD = lightPosition.xyz - pos;                                   \n\t\t    }                                                                  \n\t\t                                                                       \n\t\t    E =  -normalize( (ProjectMat * vec4(pos,1)).xyz );                 \n\t\t    N = normalize( mat3(ModelMat)*vNormal.xyz);                        \n                                                                               \n\t\t    gl_Position = CameraMat * ProjectMat * ModelMat * vPosition;       \n\t\t                                                                       \n\t\t}                                                                      \n\t",fragmentShader:"\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tuniform vec4 ambientProduct;                                       \n\t\tuniform vec4 diffuseProduct;                                       \n\t\tuniform vec4 specularProduct;                                      \n\t\tuniform float shininess;                                           \n\t\tvarying vec3 N, L, E, D;                                           \n\t\t                                                                   \n\t\tuniform float lightAtt;                                            \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    vec4 fColor;                                                   \n\t\t                                                                   \n\t\t    vec3 Ln = normalize(L);                                        \n\t\t    vec3 H = normalize( Ln + normalize(E) );                       \n\t\t    vec4 ambient = ambientProduct;                                 \n\t\t                                                                   \n\t\t    float Kd = max( dot( Ln, N), 0.0 );                            \n\t\t    vec4  diffuse = Kd*diffuseProduct;                             \n\t\t                                                                   \n\t\t    float Ks = pow( max(dot(N, H), 0.0), shininess );              \n\t\t    vec4  specular = Ks * specularProduct;                         \n\t\t                                                                   \n\t\t    if( dot(L, N) < 0.0 ) specular = vec4(0.0, 0.0, 0.0, 1.0);     \n\t\t                                                                   \n\t\t    float attenuation = 3.0/(1.0 + lightAtt*pow(length(D), 2.0));  \n\t\t                                                                   \n\t\t    fColor = ambient + attenuation*(diffuse + specular);           \n\t\t    fColor.a = 1.0;                                                \n\t\t                                                                   \n\t\t    gl_FragColor = fColor;                                         \n\t\t}                                                                  \n\t",getExtensions:function(){},initUniforms:function(){var a=this.glwrapper,b=a.gl,c=this.program;this.cameraUniform=b.getUniformLocation(c,"CameraMat"),this.projectUniform=b.getUniformLocation(c,"ProjectMat"),this.modelUniform=b.getUniformLocation(c,"ModelMat"),this.colorUniform=b.getUniformLocation(c,"fColor")},initBuffersAndAttributes:function(){this.program;gl.enableVertexAttribArray(this.vPosition),gl.enableVertexAttribArray(this.vNormal),this.dynamicVerticesBuffer=gl.createBuffer(),this.dynamicNormalsBuffer=gl.createBuffer()},disableAttributes:function(){var a=this.glwrapper.gl;a.disableVertexAttribArray(this.vPosition),a.disableVertexAttribArray(this.vNormal)},renderScene:function(a,b){var c=this.glwrapper,d=c.gl;if(!a)throw"Call useScene() to set the scene before calling draw()!";if(!b)throw"Call useCamera() to set a camera before calling draw()!";d.uniformMatrix4fv(this.cameraUniform,!1,b.perspective.flatten()),d.uniformMatrix4fv(this.projectUniform,!1,b.getAbsoluteTransform().inverse().flatten()),a.draw(this,new Mat4)},drawTriangleMesh:function(a,b){var c=this.glwrapper,d=c.gl,e=this.program;if(a.key){if(!c.verticesCache[a.key]||!c.normalsCache[a.key]){var f=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,f),d.bufferData(d.ARRAY_BUFFER,this.flattenTriangles(a.triangles),d.STATIC_DRAW),c.verticesCache[a.key]=f;var g=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,g),d.bufferData(d.ARRAY_BUFFER,this.flattenTriangles(a.normals),d.STATIC_DRAW),c.normalsCache[a.key]=g}d.bindBuffer(d.ARRAY_BUFFER,c.verticesCache[a.key]),d.vertexAttribPointer(this.vPosition,3,d.FLOAT,!1,0,0),d.bindBuffer(d.ARRAY_BUFFER,c.normalsCache[a.key]),d.vertexAttribPointer(this.vNormal,3,d.FLOAT,!1,0,0)}else d.bindBuffer(d.ARRAY_BUFFER,c.dynamicVerticesBuffer),d.bufferData(d.ARRAY_BUFFER,this.flattenTriangles(a.triangles),d.STATIC_DRAW),d.vertexAttribPointer(this.vPosition,3,d.FLOAT,!1,0,0),d.bindBuffer(d.ARRAY_BUFFER,c.dynamicNormalsBuffer),d.bufferData(d.ARRAY_BUFFER,this.flattenTriangles(a.normals),d.STATIC_DRAW),d.vertexAttribPointer(this.vNormal,3,d.FLOAT,!1,0,0);if(!(a.color&&a.color[3]<=0)){var h=Vector.multiply(c.lightAmbient,a.ambient),i=Vector.multiply(c.lightDiffuse,a.diffuse),j=Vector.multiply(c.lightSpecular,a.specular);d.uniform4fv(d.getUniformLocation(e,"lightPosition"),this.flatten(c.lightPosition)),d.uniform1f(d.getUniformLocation(e,"lightAtt"),c.lightAttenuation),d.uniform4fv(d.getUniformLocation(e,"ambientProduct"),this.flatten(h)),d.uniform4fv(d.getUniformLocation(e,"diffuseProduct"),this.flatten(i)),d.uniform4fv(d.getUniformLocation(e,"specularProduct"),this.flatten(j)),d.uniform1f(d.getUniformLocation(e,"shininess"),a.shininess),d.uniformMatrix4fv(this.modelUniform,!1,this.flattenTransform(b)),d.drawArrays(d.TRIANGLES,0,3*a.triangles.length)}}};PhongShader.prototype=Object.create(Shader.prototype);for(var prop in proto)PhongShader.prototype[prop]=proto[prop];var proto={key:"gouraud",vertexShader:"\t\t                                                                              \n\t\tattribute vec3 vPosition;                                                     \n\t\tattribute vec3 vNormal;                                                       \n\t\t                                                                              \n\t\tvarying vec4 fColor;                                                          \n\t\t                                                                              \n\t\tuniform mat4 ModelMat;                                                        \n\t\tuniform mat4 CameraMat;                                                       \n\t\tuniform mat4 ProjectMat;                                                      \n\t\t                                                                              \n\t\tuniform vec4 ambientProduct, diffuseProduct, specularProduct;                 \n\t\t                                                                              \n\t\tuniform vec4 lightPosition;                                                   \n\t\tuniform float lightAtt;                                                       \n\t\tuniform float shininess;                                                      \n\t\tuniform mat3 normalMatrix;                                                    \n\t\t                                                                              \n\t\t                                                                              \n\t\tvoid                                                                          \n\t\tmain()                                                                        \n\t\t{                                                                             \n\t\t    vec4 vPos4 = vec4(vPosition, 1);                                          \n\t\t                                                                              \n\t\t    vec3 pos = (ModelMat * vPos4).xyz; //pos from eye (origin)                \n\t\t    vec3 toLight; //vector from vertex position to light source               \n\t\t                                                                              \n\t\t    float attenuation;                                                        \n\t\t                                                                              \n\t\t    // check for directional light                                            \n\t\t    if(lightPosition.w == 0.0) {                                              \n\t\t        toLight = normalize(lightPosition.xyz);                               \n\t\t        attenuation = 1.0;                                                    \n\t\t    } else {                                                                  \n\t\t        toLight = normalize( lightPosition.xyz - pos );                       \n\t\t        float distance = length(lightPosition.xyz - pos);                     \n\t\t        attenuation = 1.0/(1.0 + lightAtt * pow(distance, 2.0));              \n\t\t    }                                                                         \n\t\t                                                                              \n\t\t                                                                              \n\t\t    vec3 toEye = -normalize( pos ); //vertex to eye (note: eye at origin)     \n\t\t                                                                              \n\t\t    vec3 halfway = normalize( toLight + toEye ); //Halfway vector             \n\t\t                                                                              \n\t\t    //transform vertex normal to match object transform                       \n\t\t    vec3 N = normalize( mat3(ModelMat) * vNormal);                            \n\t\t                                                                              \n\t\t    // Compute terms in the illumination equation                             \n\t\t    vec4 ambient = ambientProduct;                                            \n\t\t                                                                              \n\t\t    float Kd = max( dot(toLight, N), 0.0 );                                   \n\t\t    vec4  diffuse = Kd*diffuseProduct;                                        \n\t\t                                                                              \n\t\t    float Ks = pow( max(dot(N, halfway), 0.0), shininess );                   \n\t\t    vec4  specular = Ks * specularProduct;                                    \n\t\t                                                                              \n\t\t    if( dot(toLight, N) < 0.0 ) {                                             \n\t\t    specular = vec4(0.0, 0.0, 0.0, 1.0);                                      \n\t\t    }                                                                         \n\t\t                                                                              \n\t\t    gl_Position = CameraMat * ProjectMat * ModelMat * vPos4;                  \n\t\t                                                                              \n\t\t    fColor = ambient + attenuation*(diffuse + specular);                      \n\t\t                                                                              \n\t\t    fColor.a = 1.0;                                                           \n\t\t}                                                                             \n\t",
fragmentShader:"\t\tprecision mediump float;     \n\t\tvarying vec4 fColor;         \n\t\t                             \n\t\tvoid main() {                \n\t\t    gl_FragColor = fColor;   \n\t\t}                            \n    "};GouraudShader.prototype=Object.create(PhongShader.prototype);for(var prop in proto)GouraudShader.prototype[prop]=proto[prop];var proto={key:"basic",vertexShader:"\t\t                                                                       \n\t\tattribute vec4 vPosition;                                              \n\t\t                                                                       \n\t\tuniform mat4 CameraMat;                                                \n\t\tuniform mat4 ProjectMat;                                               \n\t\tuniform mat4 ModelMat;                                                 \n\t\t                                                                       \n\t\tvoid main()                                                            \n\t\t{                                                                      \n\t\t    gl_Position = CameraMat * ProjectMat * ModelMat * vPosition;       \n\t\t}                                                                      \n\t",fragmentShader:"\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tuniform vec4 fColor;                                               \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    gl_FragColor = fColor;                                         \n\t\t}                                                                  \n\t",initUniforms:PhongShader.prototype.initUniforms,initBuffersAndAttributes:function(){var a=this.glwrapper,b=a.gl;this.program;b.enableVertexAttribArray(this.vPosition),a.dynamicVerticesBuffer=b.createBuffer()},disableAttributes:function(){this.glwrapper.gl.disableVertexAttribArray(this.vPosition)},renderScene:PhongShader.prototype.renderScene,drawTriangleMesh:function(a,b){var c=this.glwrapper,d=c.gl,e=this.program;if(a.key){if(!c.verticesCache[a.key]){var f=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,f),d.bufferData(d.ARRAY_BUFFER,this.flattenTriangles(a.triangles),d.STATIC_DRAW),c.verticesCache[a.key]=f}d.bindBuffer(d.ARRAY_BUFFER,c.verticesCache[a.key]),d.vertexAttribPointer(this.vPosition,3,d.FLOAT,!1,0,0)}else d.bindBuffer(d.ARRAY_BUFFER,c.dynamicVerticesBuffer),d.bufferData(d.ARRAY_BUFFER,this.flattenTriangles(a.triangles),d.STATIC_DRAW),d.vertexAttribPointer(this.vPosition,3,d.FLOAT,!1,0,0);a.color&&a.color[3]<=0||(d.uniform4fv(d.getUniformLocation(e,"fColor"),this.flatten(a.color)),d.uniformMatrix4fv(this.modelUniform,!1,this.flattenTransform(b)),d.drawArrays(d.TRIANGLES,0,3*a.triangles.length))}};BasicShader.prototype=Object.create(Shader.prototype);for(var prop in proto)BasicShader.prototype[prop]=proto[prop];var proto={key:"basicgbuffer",fragmentShader:"\t\t                                                                   \n\t\t#extension GL_EXT_draw_buffers : require                           \n\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tuniform vec4 fColor;                                               \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    // store rgba components separately                            \n\t\t    gl_FragData[0] = vec4(fColor.r);                               \n\t\t    gl_FragData[1] = vec4(fColor.g);                               \n\t\t    gl_FragData[2] = vec4(fColor.b);                               \n\t\t    gl_FragData[3] = vec4(fColor.a);                               \n\t\t}                                                                  \n\t",getExtensions:function(){var a=this.glwrapper.gl;this.ext||(this.ext=a.getExtension("WEBGL_draw_buffers"),a.getExtension("OES_texture_float"),a.getExtension("OES_texture_float_linear"))},initBuffersAndAttributes:function(){var a=this.glwrapper,b=a.gl;b.bindFramebuffer(b.FRAMEBUFFER,this.fb),b.bindRenderbuffer(b.RENDERBUFFER,this.depthBuffer),BasicShader.prototype.initBuffersAndAttributes.call(this)}};BasicGBufferShader.prototype=Object.create(BasicShader.prototype);for(var prop in proto)BasicGBufferShader.prototype[prop]=proto[prop];var proto={key:"basicTexture",vertexShader:"\t\t                                                                       \n\t\tattribute vec4 vPosition;                                              \n\t\tattribute vec4 vNormal;                                                \n\t\t                                                                       \n\t\tuniform mat4 CameraMat;                                                \n\t\tuniform mat4 ProjectMat;                                               \n\t\tuniform mat4 ModelMat;                                                 \n\t\t                                                                       \n\t\tattribute  vec2 vTexCoord;                                             \n\t\t                                                                       \n\t\tvarying vec2 fTexCoord;                                                \n\t\t                                                                       \n\t\tvoid main()                                                            \n\t\t{                                                                      \n\t\t\tfTexCoord = vTexCoord;                                             \n                                                                               \n\t\t    gl_Position = CameraMat * ProjectMat * ModelMat * vPosition;       \n\t\t                                                                       \n\t\t}                                                                      \n\t",fragmentShader:"\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tvarying vec2 fTexCoord;                                            \n\t\t                                                                   \n\t\tuniform sampler2D texture;                                         \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t    \tgl_FragColor = texture2D( texture, fTexCoord );                \n\t\t}                                                                  \n\t",initBuffersAndAttributes:function(){var a=this.glwrapper,b=a.gl,c=this.program;b.enableVertexAttribArray(this.vTexCoord),b.activeTexture(b.TEXTURE0),b.uniform1i(b.getUniformLocation(c,"texture"),0),BasicShader.prototype.initBuffersAndAttributes.call(this)},disableAttributes:function(){var a=this.glwrapper.gl;BasicShader.prototype.disableAttributes.call(this),a.disableVertexAttribArray(this.vTexCoord)},drawTriangleMesh:function(a,b){var c=this.glwrapper.gl;a&&a.texture&&c.bindTexture(c.TEXTURE_2D,a.texture),c.bindBuffer(c.ARRAY_BUFFER,this.textureBuffer),c.bufferData(c.ARRAY_BUFFER,this.flattenVertices(a.texCoords),c.STATIC_DRAW),c.vertexAttribPointer(this.vTexCoord,2,c.FLOAT,!1,0,0),BasicShader.prototype.drawTriangleMesh.call(this,a,b)}};TextureShader.prototype=Object.create(BasicShader.prototype);for(var prop in proto)TextureShader.prototype[prop]=proto[prop];var proto={key:"background",vertexShader:"\t\t                                                                       \n\t\tattribute vec2 vCoord; // passed in coordinates range from -1 to 1     \n\t\t                                                                       \n\t\tvarying vec2 fTexCoord;                                                \n\t\t                                                                       \n\t\tvoid main()                                                            \n\t\t{                                                                      \n\t\t\t// texture coordinates range from 0 to 1                           \n\t\t\tfTexCoord = vCoord * 0.5 + vec2(0.5);                              \n\t\t                                                                       \n\t\t    // gl_position coordinates range from -1 to 1                      \n\t\t    gl_Position = vec4(vCoord, 0.0, 1.0);                              \n\t\t}                                                                      \n\t",fragmentShader:"\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tvarying vec2 fTexCoord;                                            \n\t\t                                                                   \n\t\tuniform sampler2D texture;                                         \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    gl_FragColor = texture2D( texture, fTexCoord );                \n\t\t}                                                                  \n\t",initBuffersAndAttributes:function(){var a=this.glwrapper.gl,b=this.program;a.bindBuffer(a.ARRAY_BUFFER,this.vCoordBuffer),a.bufferData(a.ARRAY_BUFFER,this.flattenTriangles(this.quadMesh.triangles),a.STATIC_DRAW),a.vertexAttribPointer(this.vCoord,2,a.FLOAT,!1,0,0),a.enableVertexAttribArray(this.vCoord),a.activeTexture(a.TEXTURE0),a.uniform1i(a.getUniformLocation(b,"texture"),0)},disableAttributes:function(){this.glwrapper.gl.disableVertexAttribArray(this.vCoord)},quadMesh:new TriangleMesh({key:"quadmesh",vertices:[vec2(-1,-1),vec2(1,-1),vec2(1,1),vec2(-1,1)],indices:[[0,1,2],[0,2,3]],normals:[],color:vec4(1,1,1,1)}),renderScene:function(){this.drawTriangleMesh()},drawTriangleMesh:function(a){var b=this.glwrapper.gl;this.program;a&&a.texture&&b.bindTexture(b.TEXTURE_2D,a.texture),b.drawArrays(b.TRIANGLES,0,3*this.quadMesh.triangles.length)}};BackgroundShader.prototype=Object.create(Shader.prototype);for(var prop in proto)BackgroundShader.prototype[prop]=proto[prop];var proto={key:"basicquad",fragmentShader:"\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tvarying vec2 fTexCoord;                                            \n\t\t                                                                   \n\t\tuniform sampler2D tex0;                                            \n\t\tuniform sampler2D tex1;                                            \n\t\tuniform sampler2D tex2;                                            \n\t\tuniform sampler2D tex3;                                            \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    vec4 fColor;                                                   \n\t\t                                                                   \n\t\t\tvec4 texData0 = texture2D(tex0, fTexCoord);                    \n\t\t\tvec4 texData1 = texture2D(tex1, fTexCoord);                    \n\t\t\tvec4 texData2 = texture2D(tex2, fTexCoord);                    \n\t\t\tvec4 texData3 = texture2D(tex3, fTexCoord);                    \n\t\t                                                                   \n\t\t    // reconstruct color from rgba components                      \n\t\t\tfColor = vec4(texData0.x, texData1.x, texData2.x, 1);          \n\t\t                                                                   \n\t\t    gl_FragColor = fColor;                                         \n\t\t}                                                                  \n\t",initUniforms:function(){var a=this.glwrapper.gl,b=this.program,c=this.glwrapper.texs;a.bindFramebuffer(a.FRAMEBUFFER,null),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,c[0]),a.uniform1i(a.getUniformLocation(b,"tex0"),0),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,c[1]),a.uniform1i(a.getUniformLocation(b,"tex1"),1),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,c[2]),a.uniform1i(a.getUniformLocation(b,"tex2"),2),a.activeTexture(a.TEXTURE3),a.bindTexture(a.TEXTURE_2D,c[3]),a.uniform1i(a.getUniformLocation(b,"tex3"),3)}};BasicQuadShader.prototype=Object.create(BackgroundShader.prototype);for(var prop in proto)BasicQuadShader.prototype[prop]=proto[prop];var proto={key:"gbuffer",vertexShader:"\t\t                                                                       \n\t\tattribute vec4 vPosition;                                              \n\t\tattribute vec4 vNormal;                                                \n\t\t                                                                       \n\t\tvarying vec3 N, pos;                                                   \n\t\tuniform mat4 CameraMat;                                                \n\t\tuniform mat4 ProjectMat;                                               \n\t\tuniform mat4 ModelMat;                                                 \n\t\tuniform vec4 lightPosition;                                            \n\t\tuniform mat3 normalMatrix;                                             \n\t\t                                                                       \n\t\tvoid main()                                                            \n\t\t{                                                                      \n\t\t    pos = (ProjectMat * ModelMat * vPosition).xyz;                     \n\t\t                                                                       \n\t\t    N = normalize( mat3(ProjectMat * ModelMat) * vNormal.xyz);         \n                                                                               \n\t\t    gl_Position = CameraMat * ProjectMat * ModelMat * vPosition;       \n\t\t                                                                       \n\t\t}                                                                      \n\t",fragmentShader:"\t\t                                                                   \n\t\t#extension GL_EXT_draw_buffers : require                           \n\t\t                                                                   \n\t\tprecision mediump float;                                           \n                                                                           \n\t\t// material factors                                                \n\t\tuniform float ambient;                                             \n\t\tuniform float specular;                                            \n\t\tuniform float diffuse;                                             \n\t\tuniform float shininess;                                           \n\t\t                                                                   \n\t\t// material color                                                  \n\t\tuniform vec4 materialColor;                                        \n\t\t                                                                   \n\t\tvarying vec3 N, pos;                                               \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    // store rgba components separately                            \n\t\t    gl_FragData[0] = vec4(pos, 1.0);                               \n\t\t    gl_FragData[1] = vec4(N, 1.0);                                 \n\t\t    gl_FragData[2] = vec4(ambient, diffuse, specular, shininess);  \n\t\t    gl_FragData[3] = materialColor;                                \n\t\t}                                                                  \n\t",initUniforms:PhongShader.prototype.initUniforms,initBuffersAndAttributes:function(){BasicGBufferShader.prototype.initBuffersAndAttributes.call(this),PhongShader.prototype.initBuffersAndAttributes.call(this)},disableAttributes:function(){BasicGBufferShader.prototype.disableAttributes.call(this),PhongShader.prototype.disableAttributes.call(this)},renderScene:function(a,b){this.glwrapper.lights=[],PhongShader.prototype.renderScene.call(this,a,b)},drawTriangleMesh:function(a,b){gl.uniform1f(gl.getUniformLocation(this.program,"ambient"),a.ambientFactor),gl.uniform1f(gl.getUniformLocation(this.program,"diffuse"),a.diffuseFactor),gl.uniform1f(gl.getUniformLocation(this.program,"specular"),a.specularFactor),gl.uniform1f(gl.getUniformLocation(this.program,"shininess"),a.shininess),gl.uniform4fv(gl.getUniformLocation(this.program,"materialColor"),this.flatten(a.color)),PhongShader.prototype.drawTriangleMesh.call(this,a,b)}};GBufferShader.prototype=Object.create(BasicGBufferShader.prototype);for(var prop in proto)GBufferShader.prototype[prop]=proto[prop];var proto={key:"phongquad",fragmentShader:"\t\t                                                                   \n\t\tprecision mediump float;                                           \n\t\t                                                                   \n\t\tvarying vec2 fTexCoord;                                            \n\t\t                                                                   \n\t\tuniform sampler2D tex0;                                            \n\t\tuniform sampler2D tex1;                                            \n\t\tuniform sampler2D tex2;                                            \n\t\tuniform sampler2D tex3;                                            \n\t\t                                                                   \n\t\tuniform mat4 ProjectMat;                                           \n\t\tuniform mat4 ModelMat;                                             \n\t\t                                                                   \n\t\tuniform vec4 lightPosition;                                        \n\t\tuniform float lightAtt;                                            \n\t\t                                                                   \n\t\t// simplify things by merging light properties into one color      \n\t\tuniform vec4 lightColor;                                           \n\t\t                                                                   \n\t\tvoid main()                                                        \n\t\t{                                                                  \n\t\t    vec4 fColor;                                                   \n\t\t                                                                   \n\t\t\tvec3 pos = texture2D(tex0, fTexCoord).rgb;                     \n\t\t\tvec3 N = texture2D(tex1, fTexCoord).rgb;                       \n\t\t\tvec4 factors = texture2D(tex2, fTexCoord);                     \n\t\t\tfloat AFactor = factors.r; // ambient                          \n\t\t\tfloat DFactor = factors.g; // diffuse                          \n\t\t\tfloat SFactor = factors.b; // specular                         \n\t\t\tfloat shininess = factors.a;                                   \n\t\t\tvec4 materialColor = texture2D(tex3, fTexCoord);               \n\t\t                                                                   \n\t\t\tvec4 ambientProduct = lightColor * (AFactor * materialColor);  \n\t\t\tvec4 diffuseProduct = lightColor * (DFactor * materialColor);  \n\t\t\tvec4 specularProduct = lightColor * (SFactor * materialColor); \n\t\t                                                                   \n\t\t    // use transformations to move light from (0,0,0)              \n\t\t\tvec4 lightPos = ProjectMat * ModelMat * vec4(0,0,0,1);         \n\t\t                                                                   \n\t\t    // remember: pos and lightPos relative to camera               \n\t\t    vec3 E =  -normalize( pos ); // object to camera               \n\t\t    vec3 D = lightPos.xyz - pos; // object to light                \n\t\t    vec3 L = normalize( D ); // normalized object to light         \n\t\t                                                                   \n\t\t    vec3 H = normalize( L + E ); // halfway vector                 \n\t\t    vec4 ambient = ambientProduct;                                 \n\t\t                                                                   \n\t\t    float Kd = max( dot( L, N), 0.0 );                             \n\t\t    vec4  diffuse = Kd * diffuseProduct;                           \n                                                                           \n\t\t    float Ks = pow( max(dot(N, H), 0.0), shininess );              \n\t\t    vec4  specular = Ks * specularProduct;                         \n\t\t                                                                   \n\t\t    if( dot(L, N) < 0.0 ) specular = vec4(0.0, 0.0, 0.0, 1.0);     \n\t\t                                                                   \n\t\t    float attenuation = 3.0/(1.0 + lightAtt*pow(length(D), 2.0));  \n\t\t                                                                   \n\t\t    fColor = ambient + attenuation*(diffuse + specular);           \n\t\t    fColor.a = 1.0;                                                \n\t\t                                                                   \n\t\t    gl_FragColor = fColor;                                         \n\t\t}                                                                  \n\t",renderScene:function(){this.glwrapper.lights.forEach(this.renderLighting.bind(this))},renderLighting:function(a){var b=this.glwrapper,c=b.gl,d=this.program;c.uniform4fv(c.getUniformLocation(d,"lightColor"),this.flatten(a.color)),c.uniform4fv(c.getUniformLocation(d,"lightPosition"),this.flatten(vec4(0,0,0,1))),c.uniform1f(c.getUniformLocation(d,"lightAtt"),a.attenuation);var e=b.camera.getAbsoluteTransform().inverse();c.uniformMatrix4fv(c.getUniformLocation(d,"ProjectMat"),!1,e.flatten()),c.uniformMatrix4fv(c.getUniformLocation(d,"ModelMat"),!1,this.flattenTransform(a.transform)),BasicQuadShader.prototype.renderScene.call(this)}};PhongQuadShader.prototype=Object.create(BasicQuadShader.prototype);for(var prop in proto)PhongQuadShader.prototype[prop]=proto[prop];var proto={calcPerspective:function(a){this.aspect=a,this.perspective=(new Mat4).perspective(this.fov,a,this.near,this.far)}};Camera.prototype=Object.create(SimpleCartesia.prototype);for(var key in proto)Camera.prototype[key]=proto[key];var proto={corners:[vec3(-1,-1,1),vec3(1,-1,1),vec3(1,1,1),vec3(-1,1,1),vec3(-1,-1,-1),vec3(1,-1,-1),vec3(1,1,-1),vec3(-1,1,-1),vec3(0,0,1),vec3(1,0,0),vec3(0,1,0),vec3(0,0,-1),vec3(-1,0,0),vec3(0,-1,0)],triangles:[[0,1,2],[0,2,3],[1,5,6],[1,6,2],[3,2,6],[3,6,7],[5,4,7],[5,7,6],[4,0,3],[4,3,7],[1,0,4],[1,4,5]],normals:[8,8,8,8,8,8,9,9,9,9,9,9,10,10,10,10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13,13,13,13],border:[0,3,2,1,5,6,7,4,0,1,2,6,5,4,7,3]};Cube.prototype=Object.create(TriangleMeshSimpleCartesia.prototype);for(var key in proto)Cube.prototype[key]=proto[key];var proto={draw:function(a,b){switch(this.shadeStyle){case"phong":this.mesh=this.smoothMesh;break;case"gouraud":this.mesh=this.smoothMesh;break;case"flat":this.mesh=this.flatMesh;break;default:this.mesh=this.smoothMesh}TriangleMeshSimpleCartesia.prototype.draw.call(this,a,b)}};Sphere.prototype=Object.create(TriangleMeshSimpleCartesia.prototype);for(var key in proto)Sphere.prototype[key]=proto[key];
//# sourceMappingURL=sourceMap.map